import pytest
import hypothesis as hyp
import hypothesis.strategies as st

import numpy as np

import simulacra.units as u

import ionization as ion


FIXED_STEP_EVOLUTION_METHOD_TYPES = [
    ion.ide.ForwardEulerMethod,
    ion.ide.BackwardEulerMethod,
    ion.ide.TrapezoidMethod,
    ion.ide.RungeKuttaFourMethod,
]


@pytest.mark.parametrize("evolution_method_type", FIXED_STEP_EVOLUTION_METHOD_TYPES)
@hyp.settings(max_examples=10, deadline=None)
@hyp.given(
    b_initial_real=st.floats(allow_nan=False, allow_infinity=False),
    b_initial_imag=st.floats(allow_nan=False, allow_infinity=False),
)
def test_with_no_potential_final_state_is_initial_state_length_gauge(
    evolution_method_type, b_initial_real, b_initial_imag
):
    b_initial = b_initial_real + (1j * b_initial_imag)

    sim = ion.ide.IntegroDifferentialEquationSpecification(
        "test",
        b_initial=b_initial,
        time_initial=0 * u.asec,
        time_final=100 * u.asec,
        evolution_method=evolution_method_type(),
    ).to_sim()

    sim.run()

    assert np.allclose(sim.b[-1], b_initial)


# expected results for the test just below
# generated by running the simulation - may change if the algorithm changes!
EXPECTED_TEST_RESULTS = {
    ion.ide.ForwardEulerMethod: 0.11392725334866653,
    ion.ide.BackwardEulerMethod: 0.10407548854993905,
    ion.ide.TrapezoidMethod: 0.10891475259299933,
    ion.ide.RungeKuttaFourMethod: 0.10898054046019617,
}


@pytest.mark.parametrize("evolution_method_type", FIXED_STEP_EVOLUTION_METHOD_TYPES)
def test_fixed_step_evolution_method_gives_expected_result_for_hydrogen_kernel_and_gaussian_pulse(
    evolution_method_type
):
    pulse = ion.potentials.GaussianPulse.from_number_of_cycles(
        pulse_width=100 * u.asec, fluence=2 * u.Jcm2, phase=0, number_of_cycles=3
    )

    sim = ion.ide.IntegroDifferentialEquationSpecification(
        f"{evolution_method_type.__name__}",
        evolution_method=evolution_method_type(),
        time_initial=-4 * pulse.pulse_width,
        time_final=4 * pulse.pulse_width,
        time_step=1 * u.asec,
        electric_potential=pulse,
        kernel=ion.ide.LengthGaugeHydrogenKernel(),
    ).to_sim()

    sim.run()

    assert np.allclose(sim.b2[-1], EXPECTED_TEST_RESULTS[evolution_method_type])
